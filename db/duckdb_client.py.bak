import duckdb
import pandas as pd
from datetime import date
import os

class DuckDBClient:
    def __init__(self, db_path='salesRAG.duck'):
        # 确保数据库路径是正确的，即使程序是从其他目录运行的
        script_dir = os.path.dirname(os.path.abspath(__file__))
        full_db_path = os.path.join(script_dir, db_path)
        print(f"Connecting to database at: {full_db_path}") # 调试信息
        self.con = duckdb.connect(full_db_path)

    def query(self, sql: str):
        try:
            # 打印查询语句，便于调试
            print(f"Executing SQL: {sql}")
            return self.con.execute(sql).fetchdf()
        except Exception as e:
            print(f"Query Error: {e}") # 打印错误信息
            return pd.DataFrame([{"error": str(e)}])

    def init_table_meta(self):
            """
            初始化或更新 table_meta 表。

            table_meta 表结构：(table_name TEXT, column_en TEXT, column_cn TEXT, column_type TEXT)
            
            Args:
                table_meta_data (list): 包含表元数据的列表，每个元素是一个字典，
                                        键为 table_name, column_en, column_cn, column_type。
            """
            
            # 1. 创建 table_meta 表（如果不存在）
            create_table_sql = """
            CREATE TABLE IF NOT EXISTS table_meta (
                source VARCHAR, 
                table_name VARCHAR, 
                column_en VARCHAR, 
                column_cn VARCHAR, 
                column_type VARCHAR，
                PRIMARY KEY (source, column_cn)
            );
            """
            try:
                print("Executing SQL: Creating table_meta if not exists...")
                self.con.execute(create_table_sql)
            except Exception as e:
                print(f"Error creating table_meta: {e}")
                pass

    def get_table_list_with_sources(self) -> pd.DataFrame:
        """
        从 table_meta 表中获取所有独特的表名及其描述 (source)。
        
        Returns:
            pd.DataFrame: 包含 table_name 和 source 的 DataFrame。
        """
        sql = "SELECT DISTINCT table_name, source FROM main.table_meta ORDER BY table_name;"
        return self.query(sql)

    def generate_table_schema_prompt(self, table_name: str) -> str:
            """
            从 table_meta 表中提取信息，生成供 LLM 使用的数据库表结构说明 prompt。
            格式为 CREATE TABLE 语句，其中包含中文注释。

            Returns:
                str: 包含所有表结构的字符串 prompt。
            """
            # 1. 查询 table_meta 表以获取所有元数据
            # query_sql = "SELECT source, table_name, column_en, column_cn, column_type FROM table_meta ORDER BY source, table_name, column_en"
            query_sql = f"SELECT column_en, column_cn, column_type FROM main.table_meta WHERE table_name = '{table_name}' ORDER BY column_en"
            meta_df = self.query(query_sql)

            if meta_df.empty or "error" in meta_df.columns:
                print("Warning: table_meta is empty or query failed. Cannot generate schema prompt.")
                return "No table schema information available."

            # 2. 按 (source, table_name) 分组，构建表结构
            prompt_parts = ["数据库包含以下表结构："]
            
            # 记录已处理的表，键为 (source, table_name)
            grouped_data = meta_df.groupby(['table_name'])

            for (table_name,), group in grouped_data:
                # 开始构建 CREATE TABLE 语句
                prompt_parts.append(f"\n")
                prompt_parts.append(f"{table_name} (")

                column_definitions = []
                for index, row in group.iterrows():
                    column_en = row['column_en']
                    column_cn = row['column_cn']
                    column_type = row['column_type']

                    # 格式: column_en column_type -- column_cn
                    definition = f"    {column_en} {column_type} -- {column_cn}"
                    column_definitions.append(definition)

                # 将列定义用逗号连接
                table_schema = ",\n".join(column_definitions)
                prompt_parts.append(table_schema)
                prompt_parts.append(");")
            
            return "\n".join(prompt_parts)

# --- 以下是新增的调试块 ---
if __name__ == "__main__":
    # 1. 实例化客户端
    client = DuckDBClient()

    print(client.generate_table_schema_prompt())
    # client.init_table_meta()    
    # 注意：在实际调试前，您可能需要确保 salesRAG.duck 文件存在，或者至少允许程序创建它
    # query_sql = """
    # select max(trade_date) from etf_daily;
    # """
    # result_df=client.query(query_sql)
    # print("\n--- Test Query Result ---")
    # print(result_df)
    
    client.con.close()
    